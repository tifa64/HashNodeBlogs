---
title: "Template for solving Dynamic Programming problems"
datePublished: Mon Dec 16 2024 17:53:32 GMT+0000 (Coordinated Universal Time)
cuid: cm4rc2t47000209mpeptv48z4
slug: template-for-solving-dynamic-programming-problems
tags: dynamic-programming

---

Inspired by [this leetcode post](https://leetcode.com/discuss/study-guide/458695/Dynamic-Programming-Patterns)

Read [this as prerequisit](https://hashnode.com/post/cm4r9jz6400000ajs1knlghdg)


### 1. **Minimum (Maximum) Path to Reach a Target**
- **Problem Statement**: Given a target, find the minimum (or maximum) cost/path/sum to reach the target.
- **Top-Down Approach**: Recursively compute the minimum (or maximum) cost for each possible path to the target, memoizing intermediate results to avoid redundant calculations.
  ```cpp
  for (int j = 0; j < ways.size(); ++j) {
      result = min(result, topDown(target - ways[j]) + cost/path/sum);
  }
  return memo[state] = result;
  ```

### 2. **Distinct Ways**
- **Problem Statement**: Given a target, find the number of distinct ways to reach the target.
- **Top-Down Approach**: Recursively calculate the sum of all possible ways to reach the target by using subproblems, and memoize the results.
  ```cpp
  for (int j = 0; j < ways.size(); ++j) {
      result += topDown(target - ways[j]);
  }
  return memo[state] = result;
  ```

### 3. **Merging Intervals**
- **Problem Statement**: Given a set of intervals or numbers, find an optimal solution considering the current interval and the best you can get from the left and right sides.
- **Top-Down Approach**: Use recursion to consider each interval, calculating the optimal result from the left and right sides and combining them.
  ```cpp
  for (int k = i; k <= j; ++k) {
      result = max(result, topDown(nums, i, k-1) + result[k] + topDown(nums, k+1, j));
  }
  return memo[state] = result;
  ```

### 4. **DP on Strings**
- **Problem Statement**: Given two strings (or a string), return some result (e.g., longest common subsequence, edit distance).
- **Top-Down Approach**: Use two nested loops to compare characters from both strings, solving smaller subproblems recursively and memoizing results to avoid recomputation.
  ```cpp
  for (int i = 1; i <= n; ++i) {
      for (int j = 1; j <= m; ++j) {
          if (s1[i-1] == s2[j-1]) {
              dp[i][j] = dp[i-1][j-1] + 1;
          } else {
              dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
          }
      }
  }
  ```

### 5. **Decision Making**
- **Problem Statement**: Given a set of values, decide whether to use or ignore the current value based on previous results.
- **Top-Down Approach**: Recursively decide whether to include or exclude the current value based on the optimal solution for subproblems, memoizing the results.
  ```cpp
  for (int i = 1; i < n; ++i) {
      dp[i][j] = max({dp[i][j], dp[i-1][j] + arr[i], dp[i-1][j-1]});
  }
  ```

For each pattern, the general idea in the top-down approach is to define a recursive function that computes the result by breaking down the problem into smaller subproblems, using memoization to store intermediate results. This avoids recomputation and optimizes the solution for large inputs.
